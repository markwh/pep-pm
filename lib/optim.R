# Functions to aid in optimization

#' Functions generated by function factories need to be a vector function of parameters.
#' Parameters may be any combination of 3 Manning's n variants (constant, spatial, MetroMan)
#' and either A0 or not. Options are to make a single function factory for each stat with
#' variant as an argument, or a different function for each variant. 
#' 

# Function factories for optimizing based on various fit stats

#' @param evalfun A function returning an evaluation metric to be minimized. 
#'   Must be a function of (pred, meas). 
evalff <- function(swotlist, evalfun = RRMSE,
                  area = c("optim", "stat", "true"), 
                  man_n = c("single", "spatial", "metroman"),
                  qagfun = geomMean) {
  
  area <- match.arg(area)
  man_n <- match.arg(man_n)
  swotlist$dA <- rezero_dA(swotlist$dA, "median")
  
  # params is a vector of length nx + 1, with the first element 
  Qmeas <- apply(swotlist$Q, 2, qagfun)
  
  out <- function(params) {
    stopifnot(is.numeric(params))
    
    if (man_n == "single") {
      n100 <- params[1]
      n <- n100 / 100 # This scaling to keep param on par with A0
      n_n <- 1
      nmat <- matrix(n, nrow = nrow(swotlist$W), ncol = ncol(swotlist$W))
    } else if (man_n == "spatial") {
      n_n <- nrow(swotlist$W)
      n100 <- params[1:n_n]
      n <- n100 / 100
      nmat <- swot_vec2mat(n, swotlist$W)
    } else if (man_n == "metroman") {
      # log(n) = a + b * log(d) = a + b * log(A / W)
      nx <- nrow(swotlist$W)
      logd <- log(swotlist$A) - log(swotlist$W)
      a <- params[1:nx]
      b <- params[nx + (1:nx)]
      nmat <- exp(a + b * logd)
    }
    
    if (area == "optim") {
      A0.001 <- params[-1:-n_n]
      A0 <- A0.001 * 1000 # Scale to keep on par with n.
      dA <- swotlist[["dA"]]
      Amat <- swot_vec2mat(A0, dA) + dA
    } else if (area == "stat") {
      A0 <- apply(swotlist$A, 1, median, na.rm = TRUE)
      dA <- swotlist[["dA"]]
      Amat <- swot_vec2mat(A0, dA) + dA
    } else if (area == "true") {
      Amat <- swotlist[["A"]]
    }
    
    Qpredmat <- nmat^(-1) * Amat^(5/3) * swotlist$W^(-2/3) * swotlist$S^(1/2)
    Qpred <- apply(Qpredmat, 2, qagfun)
    
    out <- evalfun(Qpred, Qmeas)
    out
  }
}

#' Manning n parameters for MetroMan
npars_metroman <- function(swotlist, mc = TRUE, area = c("stat", "true"),
                           qagfun = geomMean) {
  area <- match.arg(area)
  
  Wmat <- swotlist$W
  Smat <- swotlist$S
  
  if (area == "stat") {
    swotlist$dA <- rezero_dA(swotlist$dA, "median")
    A0vec <- apply(swotlist$A, 1, median)
    Amat <- swotlist$dA + swot_vec2mat(A0vec, Wmat)
  } else if (area == "true") {
    Amat <- swotlist$A
  }

  if (mc) {
    Qvec <- apply(swotlist$Q, 2, qagfun)
    Qmat <- swot_vec2mat(Qvec, Wmat)
  } else {
    Qmat <- swotlist$Q
  }
  Qdotmat <- Wmat^(-2/3) * Amat^(5/3) * Smat^(1/2)
  nmat <- Qdotmat / Qmat
  
  # log(n) = a + b * log(d) = a + b * log(A / W)
  logd <- log(Amat) - log(Wmat) # log-depth
  
  # simple linear regression of logn on logd.
  ddf <- as.data.frame(t(logd))
  ndf <- as.data.frame(t(log(nmat)))
  dncor <- map2_dbl(ddf, ndf, cor)
  dsd <- map_dbl(ddf, sd)
  nsd <- map_dbl(ndf, sd)
  dmean <- map_dbl(ddf, mean)
  nmean <- map_dbl(ndf, mean)
  bvec <- dncor * nsd / dsd
  avec <- nmean - (bvec * dmean)
  
  amat <- swot_vec2mat(avec, Wmat)
  bmat <- swot_vec2mat(bvec, Wmat)
  nmat_pred <- exp(amat + bmat * logd)
  
  out <- list(a = avec, b = bvec, n = nmat_pred)
  out
}

#' Get Manning parameters and n from stats (and possibly regression).
#' Also compute Q based on qagfun.
#' 
#' Even in the variable-n case, Q is the same everywhere, (test is for steady-state mc).
#' 
#' @importFrom swotr swot_vec2mat
#' @importFrom purrr map2_dbl map_dbl
manning_peek <- function(swotlist, man_n = c("single", "spatial", "metroman"),
                         qagfun = geomMean, nagfun = geomMean) {
  man_n <- match.arg(man_n)
  swotlist$dA <- rezero_dA(swotlist$dA, "median")
  
  Qvec <- apply(swotlist$Q, 2, qagfun)
  A0vec <- apply(swotlist$A, 1, median)
  
  Wmat <- swotlist$W
  Smat <- swotlist$S
  Amat <- swotlist$dA + swot_vec2mat(A0vec, Wmat)
  
  Qmat <- swot_vec2mat(Qvec, Wmat)
  Qdotmat <- Wmat^(-2/3) * Amat^(5/3) * Smat^(1/2)
  nmat <- Qdotmat / Qmat
  
  params <- list(A0 = A0vec)
  
  if (man_n == "single") {
    n <- nagfun(nmat)
    nmat_pred <- matrix(n, nrow = nrow(Wmat), ncol = ncol(Wmat))
    params$n <- n
  } else if (man_n == "spatial") {
    n <- apply(nmat, 1, nagfun)
    nmat_pred <- swot_vec2mat(n, Wmat)
    params$n <- n
  } else if (man_n == "metroman") {
    npars <- npars_metroman(swotlist, mc = TRUE, area = "stat")
    nmat_pred <- npars$n
    params$n_a <- npars$a
    params$n_b <- npars$b
  }

  Qpredmat <- Qdotmat / nmat_pred
  Qpred <- apply(Qpredmat, 2, qagfun)
  
  params$Q <- Qpred
  params
}
